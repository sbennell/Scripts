#
.DESCRIPTION
	This script performs network drive mappings with PowerShell and is auto generated by the intune-drive-mapping-generator (httpsintunedrivemapping.azurewebsites.net).
	When executed under SYSTEM authority a scheduled task is created to ensure recurring script execution on each user logon.
	Updated to remove VBScript dependency and eliminate PowerShell window flash using Windows API.

.NOTES
	Author Nicola Suter, nicolonsky tech httpstech.nicolonsky.ch
	Modified VBScript removed, Windows API method implemented for completely hidden execution
#

[CmdletBinding()]
Param()

###########################################################################################
# Windows API function to hide console window immediately - NO FLASH
###########################################################################################

function Hide-ConsoleWindow {
    Add-Type -Name Window -Namespace Console -MemberDefinition '
    [DllImport(Kernel32.dll)]
    public static extern IntPtr GetConsoleWindow();
    [DllImport(user32.dll)]
    public static extern bool ShowWindow(IntPtr hWnd, Int32 nCmdShow);
    '
    
    $consolePtr = [Console.Window]GetConsoleWindow()
    [Console.Window]ShowWindow($consolePtr, 0) # 0 = SW_HIDE
}

#check if running as system
function Test-RunningAsSystem {
	[CmdletBinding()]
	param()
	process {
		return [bool]($(whoami -user) -match S-1-5-18)
	}
}

# Hide window immediately if not running as SYSTEM - ELIMINATES FLASH
if (-not (Test-RunningAsSystem)) {
    Hide-ConsoleWindow
}

###########################################################################################
# Start transcript for logging
###########################################################################################

Start-Transcript -Path $(Join-Path $envtemp DriveMapping.log)

###########################################################################################
# Input values from generator
###########################################################################################

$driveMappingJson = '[{PathMAINWORK,DriveLetterW,LabelWORK,Id0,GroupFilternull},{PathBackupARCHIVE,DriveLetterX,LabelARCHIVE,Id2,GroupFilternull},{PathMAINAPPLICATIONS,DriveLetterY,LabelAPPLICATIONS,Id3,GroupFilternull},{PathMAINCD CacheMDL,DriveLetterM,Labelmdl,Id4,GroupFilternull}]'

$driveMappingConfig = $driveMappingJson  ConvertFrom-Json -ErrorAction Stop
#used to create an array for groups
$driveMappingConfig = foreach ($d in $driveMappingConfig) {
    [PSCustomObject]@{
        Path        = $($d.Path)
        DriveLetter = $($d.DriveLetter)
        Label       = $($d.Label)
        Id          = $($d.Id)
        GroupFilter = $($d.GroupFilter -split ,)
    }
}

# Override with your Active Directory Domain Name e.g. 'ds.nicolonsky.ch' if you haven't configured the domain name as DHCP option
$searchRoot = 

# If enabled all mounted PSdrives from filesystem except os drives get disconnected if not specified in drivemapping config
$removeStaleDrives = $false

###########################################################################################
# Helper function to determine a users group membership
###########################################################################################

# Kudos for Tobias Renstr√∂m who showed me this!
function Get-ADGroupMembership {
	param(
		[parameter(Mandatory = $true)]
		[string]$UserPrincipalName
	)

	process {

		try {

			if ([string]IsNullOrEmpty($envUSERDNSDOMAIN) -and [string]IsNullOrEmpty($searchRoot)) {
				Write-Error Security group filtering won't work because `$envUSERDNSDOMAIN is not available!
				Write-Warning You can override your AD Domain in the `$overrideUserDnsDomain variable
			}
			else {

				# if no domain specified fallback to PowerShell environment variable
				if ([string]IsNullOrEmpty($searchRoot)) {
					$searchRoot = $envUSERDNSDOMAIN
				}

				$searcher = New-Object -TypeName System.DirectoryServices.DirectorySearcher
				$searcher.Filter = (&(userprincipalname=$UserPrincipalName))
				$searcher.SearchRoot = LDAP$searchRoot
				$distinguishedName = $searcher.FindOne().Properties.distinguishedname
				$searcher.Filter = (member1.2.840.113556.1.4.1941=$distinguishedName)

				[void]$searcher.PropertiesToLoad.Add(name)

				$list = [System.Collections.Generic.List[String]]@()

				$results = $searcher.FindAll()

				foreach ($result in $results) {
					$resultItem = $result.Properties
					[void]$List.add($resultItem.name)
				}

				$list
			}
		}
		catch {
			#Nothing we can do
			Write-Warning $_.Exception.Message
		}
	}
}

#Testing if groupmembership is given for user
function Test-GroupMembership {
    [CmdletBinding()]
    param (
        $driveMappingConfig,
        $groupMemberships
    )
    try {
        $obj = foreach ($d in $driveMappingConfig) {
            if (-not ([string]IsNullOrEmpty($($d.GroupFilter)))) {
                foreach ($filter in $($d.GroupFilter)) {
                    if ($groupMemberships -contains $filter) {
                        $d
                    }
                    else {
                        #no match for group
                    }
                }
            }
            else {
                $d 
            }
        }
        $obj
    }
    catch {
        Write-Error Unknown error testing group memberships $($_.Exception.Message)
    }
}

###########################################################################################
# Get current group membership for the group filter capabilities
###########################################################################################

Write-Output Running as SYSTEM $(Test-RunningAsSystem)
Write-Output Console window hidden using Windows API method

if ($driveMappingConfig.GroupFilter) {
	try {
		#check if running as user and not system
		if (-not (Test-RunningAsSystem)) {

			$groupMemberships = Get-ADGroupMembership -UserPrincipalName $(whoami -upn)
		}
	}
	catch {
		#nothing we can do
	}
}
###########################################################################################
# Mapping network drives
###########################################################################################
#Get PowerShell drives and rename properties

if (-not (Test-RunningAsSystem)) {

	$psDrives = Get-PSDrive  Where-Object { $_.Provider.Name -eq FileSystem -and $_.Root -notin @($envSystemDrive, D) } `
	 Select-Object @{N = DriveLetter; E = { $_.Name } }, @{N = Path; E = { $_.DisplayRoot } }

	# only map drives where group membership applicable
	$driveMappingConfig = Test-GroupMembership -driveMappingConfig $driveMappingConfig -groupMemberships $groupMemberships

	#iterate through all network drive configuration entries
	foreach ($drive in $driveMappingConfig) {

		try {
			#check if variable in unc path exists, e.g. for $envUSERNAME - resolving
			if ($drive.Path -match '$env') {
				$drive.Path = $ExecutionContext.InvokeCommand.ExpandString($drive.Path)
			}

			#if label is null we need to set it to empty in order to avoid error
			if ($null -eq $drive.Label) {
				$drive.Label = 
			}

			$exists = $psDrives  Where-Object { $_.Path -eq $drive.Path -or $_.DriveLetter -eq $drive.DriveLetter }
			$process = $true

			if ($null -ne $exists -and $($exists.Path -eq $drive.Path -and $exists.DriveLetter -eq $drive.DriveLetter )) {
				Write-Output Drive '$($drive.DriveLetter)' '$($drive.Path)' already exists with correct Drive Letter and Path
				$process = $false

			}
			else {
				# Mapped with wrong config - Delete it
				Get-PSDrive  Where-Object { $_.DisplayRoot -eq $drive.Path -or $_.Name -eq $drive.DriveLetter }  Remove-PSDrive -EA SilentlyContinue
			}

			if ($process) {
				Write-Output Mapping network drive $($drive.Path)
				$null = New-PSDrive -PSProvider FileSystem -Name $drive.DriveLetter -Root $drive.Path -Description $drive.Label -Persist -Scope global -EA Stop
				(New-Object -ComObject Shell.Application).NameSpace($($drive.DriveLetter)).Self.Name = $drive.Label
			}
		}
		catch {
			$available = Test-Path $($drive.Path)
			if (-not $available) {
				Write-Error Unable to access path '$($drive.Path)' verify permissions and authentication!
			}
			else {
				Write-Error $_.Exception.Message
			}
		}
	}

	# Remove unassigned drives
	if ($removeStaleDrives -and $null -ne $psDrives) {
		$diff = Compare-Object -ReferenceObject $driveMappingConfig -DifferenceObject $psDrives -Property DriveLetter -PassThru  Where-Object { $_.SideIndicator -eq = }
		foreach ($unassignedDrive in $diff) {
			Write-Warning Drive '$($unassignedDrive.DriveLetter)' has not been assigned - removing it...
			Remove-SmbMapping -LocalPath $($unassignedDrive.DriveLetter) -Force -UpdateProfile
		}
	}

	# Fix to ensure drives are mapped as persistent!
	$null = Get-ChildItem -Path HKCUNetwork -ErrorAction SilentlyContinue  ForEach-Object { New-ItemProperty -Name ConnectionType -Value 1 -Path $_.PSPath -Force -ErrorAction SilentlyContinue }
}

###########################################################################################
# End & finish transcript
###########################################################################################

Stop-transcript

###########################################################################################
# Done
###########################################################################################

#!SCHTASKCOMESHERE!#

###########################################################################################
# If this script is running under system (IME) scheduled task is created  (recurring)
# UPDATED Using Windows API method for completely hidden execution - NO FLASH
###########################################################################################

if (Test-RunningAsSystem) {

	Start-Transcript -Path $(Join-Path -Path $envtemp -ChildPath IntuneDriveMappingScheduledTask.log)
	Write-Output Running as System -- creating scheduled task which will run on user logon
	Write-Output Using Windows API method for completely hidden execution - NO FLASH

	###########################################################################################
	# Get the current script path and content and save it to the client
	###########################################################################################

	$currentScript = Get-Content -Path $($PSCommandPath)

	$schtaskScript = $currentScript[(0) .. ($currentScript.IndexOf(#!SCHTASKCOMESHERE!#) - 1)]

	$scriptSavePath = $(Join-Path -Path $envProgramData -ChildPath intune-drive-mapping-generator)

	if (-not (Test-Path $scriptSavePath)) {

		New-Item -ItemType Directory -Path $scriptSavePath -Force
	}

	$scriptSavePathName = DriveMapping.ps1

	$scriptPath = $(Join-Path -Path $scriptSavePath -ChildPath $scriptSavePathName)

	$schtaskScript  Out-File -FilePath $scriptPath -Force

	Write-Output Script saved to $scriptPath
	Write-Output Windows API hide function included in script - eliminates window flash

	###########################################################################################
	# Register a scheduled task to run for all users and execute the script on logon
	# UPDATED Script handles its own hiding via Windows API - no special parameters needed
	###########################################################################################

	$schtaskName = IntuneDriveMapping
	$schtaskDescription = Map network drives - completely hidden execution using Windows API (no flash).

	# Create triggers
	$trigger = New-ScheduledTaskTrigger -AtLogOn
	
	$class = cimclass MSFT_TaskEventTrigger rootMicrosoftWindowsTaskScheduler
	$trigger2 = $class  New-CimInstance -ClientOnly
	$trigger2.Enabled = $True
	$trigger2.Subscription = 'QueryListQuery Id=0 Path=Microsoft-Windows-NetworkProfileOperationalSelect Path=Microsoft-Windows-NetworkProfileOperational[System[Provider[@Name=''Microsoft-Windows-NetworkProfile''] and EventID=10002]]SelectQueryQueryList'

	$trigger3 = $class  New-CimInstance -ClientOnly
	$trigger3.Enabled = $True
	$trigger3.Subscription = 'QueryListQuery Id=0 Path=Microsoft-Windows-NetworkProfileOperationalSelect Path=Microsoft-Windows-NetworkProfileOperational[System[Provider[@Name=''Microsoft-Windows-NetworkProfile''] and EventID=4004]]SelectQueryQueryList'

	$trigger4 = $class  New-CimInstance -ClientOnly
	$trigger4.Enabled = $True
	$trigger4.Subscription = 'QueryListQuery Id=0 Path=Microsoft-Windows-NetworkProfileOperationalSelect Path=Microsoft-Windows-NetworkProfileOperational[System[Provider[@Name=''Microsoft-Windows-NetworkProfile''] and EventID=10000]]SelectQueryQueryList'

	# Execute task in users context
	$principal = New-ScheduledTaskPrincipal -GroupId S-1-5-32-545 -Id Author
	
	# UPDATED Regular PowerShell call - script handles its own hiding via Windows API
	$action = New-ScheduledTaskAction -Execute powershell.exe -Argument -NoProfile -ExecutionPolicy Bypass -File `$scriptPath`
	
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -Hidden -ExecutionTimeLimit (New-TimeSpan -Minutes 30) -RestartCount 3

	Write-Output Creating scheduled task with Windows API hiding method...
	Write-Output Task Name $schtaskName
	Write-Output Script Path $scriptPath
	Write-Output Action powershell.exe -NoProfile -ExecutionPolicy Bypass -File `$scriptPath`
	Write-Output No window flash - script hides itself immediately using Windows API

	# Register the scheduled task
	$null = Register-ScheduledTask -TaskName $schtaskName -Trigger $trigger,$trigger2,$trigger3,$trigger4 -Action $action -Principal $principal -Settings $settings -Description $schtaskDescription -Force
	
	Write-Output Scheduled task registered successfully
	
	# Start the task immediately for testing
	Start-ScheduledTask -TaskName $schtaskName
	
	Write-Output Scheduled task started - execution will be completely hidden

	Stop-Transcript
}

###########################################################################################
# Done - Windows API method eliminates all window visibility
###########################################################################################