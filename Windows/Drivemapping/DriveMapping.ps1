<#
.DESCRIPTION
	This script performs network drive mappings with PowerShell and is auto generated by the intune-drive-mapping-generator (https://intunedrivemapping.azurewebsites.net).
	When executed under SYSTEM authority a scheduled task is created to ensure recurring script execution on each user logon.

.NOTES
	Author: Nicola Suter, nicolonsky tech: https://tech.nicolonsky.ch
	Modified to use QuietShell instead of VBScript wrapper
#>

[CmdletBinding()]
Param()

###########################################################################################
# Start transcript for logging
###########################################################################################

Start-Transcript -Path $(Join-Path $env:temp "DriveMapping.log")

###########################################################################################
# Input values from generator
###########################################################################################

# Script version for update detection
$scriptVersion = "1.0"

$driveMappingJson = '[{"Path":"\\\\MAIN\\WORK","DriveLetter":"W","Label":"WORK","Id":0,"GroupFilter":null},{"Path":"\\\\Backup\\ARCHIVE","DriveLetter":"X","Label":"ARCHIVE","Id":2,"GroupFilter":null},{"Path":"\\\\MAIN\\APPLICATIONS","DriveLetter":"Y","Label":"APPLICATIONS","Id":3,"GroupFilter":null},{"Path":"\\\\MAIN\\CD Cache\\MDL","DriveLetter":"M","Label":"mdl","Id":4,"GroupFilter":null}]'

$driveMappingConfig = $driveMappingJson | ConvertFrom-Json -ErrorAction Stop
#used to create an array for groups
$driveMappingConfig = foreach ($d in $driveMappingConfig) {
    [PSCustomObject]@{
        Path        = $($d.Path)
        DriveLetter = $($d.DriveLetter)
        Label       = $($d.Label)
        Id          = $($d.Id)
        GroupFilter = $($d.GroupFilter -split ",")
    }
}

# Override with your Active Directory Domain Name e.g. 'ds.nicolonsky.ch' if you haven't configured the domain name as DHCP option
$searchRoot = ""

# If enabled all mounted PSdrives from filesystem except os drives get disconnected if not specified in drivemapping config
$removeStaleDrives = $false

###########################################################################################
# Helper function to determine a users group membership
###########################################################################################

# Kudos for Tobias RenstrÃ¶m who showed me this!
function Get-ADGroupMembership {
	param(
		[parameter(Mandatory = $true)]
		[string]$UserPrincipalName
	)

	process {

		try {

			if ([string]::IsNullOrEmpty($env:USERDNSDOMAIN) -and [string]::IsNullOrEmpty($searchRoot)) {
				Write-Error "Security group filtering won't work because `$env:USERDNSDOMAIN is not available!"
				Write-Warning "You can override your AD Domain in the `$overrideUserDnsDomain variable"
			}
			else {

				# if no domain specified fallback to PowerShell environment variable
				if ([string]::IsNullOrEmpty($searchRoot)) {
					$searchRoot = $env:USERDNSDOMAIN
				}

				$searcher = New-Object -TypeName System.DirectoryServices.DirectorySearcher
				$searcher.Filter = "(&(userprincipalname=$UserPrincipalName))"
				$searcher.SearchRoot = "LDAP://$searchRoot"
				$distinguishedName = $searcher.FindOne().Properties.distinguishedname
				$searcher.Filter = "(member:1.2.840.113556.1.4.1941:=$distinguishedName)"

				[void]$searcher.PropertiesToLoad.Add("name")

				$list = [System.Collections.Generic.List[String]]@()

				$results = $searcher.FindAll()

				foreach ($result in $results) {
					$resultItem = $result.Properties
					[void]$List.add($resultItem.name)
				}

				$list
			}
		}
		catch {
			#Nothing we can do
			Write-Warning $_.Exception.Message
		}
	}
}

#check if running as system
function Test-RunningAsSystem {
	[CmdletBinding()]
	param()
	process {
		return [bool]($(whoami -user) -match "S-1-5-18")
	}
}


#Testing if groupmembership is given for user
function Test-GroupMembership {
    [CmdletBinding()]
    param (
        $driveMappingConfig,
        $groupMemberships
    )
    try {
        $obj = foreach ($d in $driveMappingConfig) {
            if (-not ([string]::IsNullOrEmpty($($d.GroupFilter)))) {
                foreach ($filter in $($d.GroupFilter)) {
                    if ($groupMemberships -contains $filter) {
                        $d
                    }
                    else {
                        #no match for group
                    }
                }
            }
            else {
                $d 
            }
        }
        $obj
    }
    catch {
        Write-Error "Unknown error testing group memberships: $($_.Exception.Message)"
    }
}

###########################################################################################
# Get current group membership for the group filter capabilities
###########################################################################################

Write-Output "Running as SYSTEM: $(Test-RunningAsSystem)"

if ($driveMappingConfig.GroupFilter) {
	try {
		#check if running as user and not system
		if (-not (Test-RunningAsSystem)) {

			$groupMemberships = Get-ADGroupMembership -UserPrincipalName $(whoami -upn)
		}
	}
	catch {
		#nothing we can do
	}
}
###########################################################################################
# Mapping network drives
###########################################################################################
#Get PowerShell drives and rename properties

if (-not (Test-RunningAsSystem)) {

	$psDrives = Get-PSDrive | Where-Object { $_.Provider.Name -eq "FileSystem" -and $_.Root -notin @("$env:SystemDrive\", "D:\") } `
	| Select-Object @{N = "DriveLetter"; E = { $_.Name } }, @{N = "Path"; E = { $_.DisplayRoot } }

	# only map drives where group membership applicable
	$driveMappingConfig = Test-GroupMembership -driveMappingConfig $driveMappingConfig -groupMemberships $groupMemberships

	#iterate through all network drive configuration entries
	foreach ($drive in $driveMappingConfig) {

		try {
			#check if variable in unc path exists, e.g. for $env:USERNAME -> resolving
			if ($drive.Path -match '\$env:') {
				$drive.Path = $ExecutionContext.InvokeCommand.ExpandString($drive.Path)
			}

			#if label is null we need to set it to empty in order to avoid error
			if ($null -eq $drive.Label) {
				$drive.Label = ""
			}

			$exists = $psDrives | Where-Object { $_.Path -eq $drive.Path -or $_.DriveLetter -eq $drive.DriveLetter }
			$process = $true

			if ($null -ne $exists -and $($exists.Path -eq $drive.Path -and $exists.DriveLetter -eq $drive.DriveLetter )) {
				Write-Output "Drive '$($drive.DriveLetter):\' '$($drive.Path)' already exists with correct Drive Letter and Path"
				$process = $false

			}
			else {
				# Mapped with wrong config -> Delete it
				Get-PSDrive | Where-Object { $_.DisplayRoot -eq $drive.Path -or $_.Name -eq $drive.DriveLetter } | Remove-PSDrive -EA SilentlyContinue
			}

			if ($process) {
				Write-Output "Mapping network drive $($drive.Path)"
				$null = New-PSDrive -PSProvider FileSystem -Name $drive.DriveLetter -Root $drive.Path -Description $drive.Label -Persist -Scope global -EA Stop
				(New-Object -ComObject Shell.Application).NameSpace("$($drive.DriveLetter):").Self.Name = $drive.Label
			}
		}
		catch {
			$available = Test-Path $($drive.Path)
			if (-not $available) {
				Write-Error "Unable to access path '$($drive.Path)' verify permissions and authentication!"
			}
			else {
				Write-Error $_.Exception.Message
			}
		}
	}

	# Remove unassigned drives
	if ($removeStaleDrives -and $null -ne $psDrives) {
		$diff = Compare-Object -ReferenceObject $driveMappingConfig -DifferenceObject $psDrives -Property "DriveLetter" -PassThru | Where-Object { $_.SideIndicator -eq "=>" }
		foreach ($unassignedDrive in $diff) {
			Write-Warning "Drive '$($unassignedDrive.DriveLetter)' has not been assigned - removing it..."
			Remove-SmbMapping -LocalPath "$($unassignedDrive.DriveLetter):" -Force -UpdateProfile
		}
	}

	# Fix to ensure drives are mapped as persistent!
	$null = Get-ChildItem -Path HKCU:\Network -ErrorAction SilentlyContinue | ForEach-Object { New-ItemProperty -Name ConnectionType -Value 1 -Path $_.PSPath -Force -ErrorAction SilentlyContinue }
}

###########################################################################################
# End & finish transcript
###########################################################################################

Stop-transcript

###########################################################################################
# Done
###########################################################################################

#!SCHTASKCOMESHERE!#

###########################################################################################
# If this script is running under system (IME) scheduled task is created  (recurring)
###########################################################################################

if (Test-RunningAsSystem) {

	Start-Transcript -Path $(Join-Path -Path $env:temp -ChildPath "IntuneDriveMappingScheduledTask.log")
	Write-Output "Running as System --> creating scheduled task which will run on user logon"

	###########################################################################################
	# Get the current script path and content and save it to the client
	###########################################################################################

	$currentScript = Get-Content -Path $($PSCommandPath)

	$schtaskScript = $currentScript[(0) .. ($currentScript.IndexOf("#!SCHTASKCOMESHERE!#") - 1)]

	# Add version info to saved script for future update detection
	$versionInfo = "# Script Version: $scriptVersion"
	$schtaskScript = @($versionInfo) + $schtaskScript

	$scriptSavePath = $(Join-Path -Path $env:ProgramData -ChildPath "scripts\drive-mapping")

	if (-not (Test-Path $scriptSavePath)) {

		New-Item -ItemType Directory -Path $scriptSavePath -Force
	}

	$scriptSavePathName = "DriveMapping.ps1"

	$scriptPath = $(Join-Path -Path $scriptSavePath -ChildPath $scriptSavePathName)

	# Check if script needs updating
	$needsUpdate = $true
	if (Test-Path $scriptPath) {
		$existingScript = Get-Content -Path $scriptPath -TotalCount 5
		$existingVersion = ($existingScript | Where-Object { $_ -match "# Script Version:" }) -replace "# Script Version: ", ""
		if ($existingVersion -eq $scriptVersion) {
			Write-Output "Script version $scriptVersion already deployed, skipping update"
			$needsUpdate = $false
		}
		else {
			Write-Output "Updating script from version '$existingVersion' to '$scriptVersion'"
		}
	}

	if ($needsUpdate) {
		$schtaskScript | Out-File -FilePath $scriptPath -Force
		Write-Output "Script saved to $scriptPath"
		
		# Write registry key for Intune detection
		try {
			$regPath = "HKLM:\SOFTWARE\SOE\DriveMapping"
			if (-not (Test-Path $regPath)) {
				New-Item -Path $regPath -Force | Out-Null
			}
			Set-ItemProperty -Path $regPath -Name "Version" -Value $scriptVersion
			Set-ItemProperty -Path $regPath -Name "LastDeployed" -Value (Get-Date -Format "yyyy-MM-dd HH:mm:ss")
			Set-ItemProperty -Path $regPath -Name "ScriptPath" -Value $scriptPath
			Write-Output "Registry detection key created at $regPath"
		}
		catch {
			Write-Warning "Failed to create registry detection key: $($_.Exception.Message)"
		}
	}

	###########################################################################################
	# Setup QuietShell path (assumes QuietShell.exe is in same directory as script)
	###########################################################################################

	$quietShellPath = $(Join-Path -Path $scriptSavePath -ChildPath "QuietShell.exe")
	
	# Copy QuietShell.exe from script directory to ProgramData directory if it exists
	$sourceQuietShellPath = $(Join-Path -Path (Split-Path -Parent $PSCommandPath) -ChildPath "QuietShell.exe")
	
	if (Test-Path $sourceQuietShellPath) {
		try {
			Write-Output "Copying QuietShell.exe to $quietShellPath"
			Copy-Item -Path $sourceQuietShellPath -Destination $quietShellPath -Force
			Write-Output "QuietShell copied successfully"
		}
		catch {
			Write-Error "Failed to copy QuietShell: $($_.Exception.Message)"
			$quietShellPath = $null
		}
	}
	else {
		Write-Warning "QuietShell.exe not found in script directory: $sourceQuietShellPath"
		$quietShellPath = $null
	}

	###########################################################################################
	# Register a scheduled task to run for all users and execute the script on logon
	###########################################################################################

	$schtaskName = "IntuneDriveMapping"
	$schtaskDescription = "Map network drives from intune-drive-mapping-generator."

	$trigger = New-ScheduledTaskTrigger -AtLogOn
	
	$class = cimclass MSFT_TaskEventTrigger root/Microsoft/Windows/TaskScheduler
	$trigger2 = $class | New-CimInstance -ClientOnly
	$trigger2.Enabled = $True
	$trigger2.Subscription = '<QueryList><Query Id="0" Path="Microsoft-Windows-NetworkProfile/Operational"><Select Path="Microsoft-Windows-NetworkProfile/Operational">*[System[Provider[@Name=''Microsoft-Windows-NetworkProfile''] and EventID=10002]]</Select></Query></QueryList>'

	$trigger3 = $class | New-CimInstance -ClientOnly
	$trigger3.Enabled = $True
	$trigger3.Subscription = '<QueryList><Query Id="0" Path="Microsoft-Windows-NetworkProfile/Operational"><Select Path="Microsoft-Windows-NetworkProfile/Operational">*[System[Provider[@Name=''Microsoft-Windows-NetworkProfile''] and EventID=4004]]</Select></Query></QueryList>'

	$trigger4 = $class | New-CimInstance -ClientOnly
	$trigger4.Enabled = $True
	$trigger4.Subscription = '<QueryList><Query Id="0" Path="Microsoft-Windows-NetworkProfile/Operational"><Select Path="Microsoft-Windows-NetworkProfile/Operational">*[System[Provider[@Name=''Microsoft-Windows-NetworkProfile''] and EventID=10000]]</Select></Query></QueryList>'

	#Execute task in users context
	$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -Id "Author"
	
	# Use QuietShell if available, otherwise fall back to standard PowerShell
	if ($null -ne $quietShellPath -and (Test-Path $quietShellPath)) {
		Write-Output "Using QuietShell to execute PowerShell script silently"
		$action = New-ScheduledTaskAction -Execute $quietShellPath -Argument "`"$scriptPath`""
	}
	else {
		Write-Warning "QuietShell not available, using standard PowerShell execution"
		$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-WindowStyle Hidden -ExecutionPolicy ByPass -File `"$scriptPath`""
	}
	
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries

	$null = Register-ScheduledTask -TaskName $schtaskName -Trigger $trigger -Action $action  -Principal $principal -Settings $settings -Description $schtaskDescription -Force
	$null = Register-ScheduledTask -TaskName $schtaskName -Trigger $trigger,$trigger2,$trigger3,$trigger4 -Action $action  -Principal $principal -Settings $settings -Description $schtaskDescription -Force
	Start-ScheduledTask -TaskName $schtaskName

	Stop-Transcript
}

###########################################################################################
# Done
###########################################################################################
